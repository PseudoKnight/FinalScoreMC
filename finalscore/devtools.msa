# Script: Function Documentation
# Author: __import__

# Output colorful information about extensions and functions.
# /doc - List all known extensions, including builtins.
# /doc <extensionname> - List all functions in a given extension.
# /doc <func>[,func] [func] - List specific functions.
*:/doc [$] = >>>
    proc _get_closest(@name, @list) {
        # Search an array for a matching entry, regardless of case, and return it.
        foreach(@ext in @list) {
            if (to_lower(@ext) == to_lower(@name)) {
                return(@ext)
            }
        }
       
    }
   
    proc _desc_func(@func) {
        # Colorfully describe a function.
        try(
            @desc = reflect_docs(@func, 'description')
            @returns = reflect_docs(@func, 'type')
            @args = reflect_docs(@func, 'args')
           
            msg(color(YELLOW) . @func . ':' color(GREEN) . 'Returns' @returns .
            '.' color(BLUE) . 'Expects' @args . '.' color(YELLOW) . @desc)
        ,
            msg(color(RED) . 'Could not show information for' @func)
        )
    }
 
    if (!$) {
        # List known extensions.
        @extensions = array_keys(extension_info())
        if (@extensions) {
            msg(color(BLUE) . 'Installed extensions:')
            foreach (@extension in @extensions) {
                msg(color(RED) . ' - ' . color(GREEN) . @extension)
            }
        } else {
            msg(color(RED) . 'No extensions installed!')
        }
    } else {
        # Show functions in a given extension.
        @args = parse_args($)
        @extensions = extension_info()
       
        # Get extension name regardless of case.
        @extension = _get_closest(@args[0], array_keys(@extensions))
       
        if (@extension) {
            @extension = @extensions[@extension]
            @functions = @extension['functions']
           
            foreach (@function in @functions) {
                _desc_func(@function)
            }
        } else {
            while(@args) {
                @many = split(',', array_remove(@args, 0))
                foreach (@function in @many) {
                    # Get function name regardless of case.
                    @functionname = to_lower(@function)
                    _desc_func(@functionname)
                }
            }
        }
    }
<<<

/* 
	Lists the type and amount of events bound
*/
/bindcount = >>>
	@binds = dump_events();
	@list = associative_array();
	foreach(@bind in @binds) {
		@type = reg_match('\\((\\w+)\\).*', @bind)[1];
		if(array_index_exists(@list, @type)) {
			@list[@type] += 1;
		} else {
			@list[@type] = 1;
		}
	}
	
	foreach(@key: @value in @list) {
		msg(@key.': '.@value);
	}
<<<

/*
	Database namespace tools
*/
/namespace $action $namespace [$] = >>>
	if(!pisop(), die('You do not have permission.'))
	@data = get_values($namespace)
	if(array_size(@data) == 0, die('No keys for that namespace.'))
	switch($action) {
		case 'delete':
			foreach(@key: @value in @data) {
				clear_value(@key)
			}
			msg('Deleted '.$namespace)
			
		case 'rename':
			foreach(@key: @value in @data) {
				store_value(replace($namespace, $, @key), @data[@key])
				clear_value(@key)
			}
	}
<<<

/*
	Convert multiverse-inventories inventory to inventory array
	and then sets it to your inventory.
*/
/invconvert $player [$world = 'default'] = >>>
	if(pmode() !== 'CREATIVE') {
		die('Only do this in creative mode. This replaces your inventory.');
	}
	proc _parse_inv(@oinv, @armor = false) {
		@inv = array();
		if(@armor) {
			@inv[99] = null;
		}
		foreach(@item in @oinv) {
			@i = associative_array();
			@i['name'] = @item['is']['type'];
			if(array_index_exists(@item['is'], 'amount')) {
				@i['qty'] = @item['is']['amount'];
			}
			if(array_index_exists(@item['is'], 'damage')) {
				@i['data'] = @item['is']['damage'];
			}
			if(array_index_exists(@item['is'], 'meta')) {
				@i['meta'] = associative_array();
				if(array_index_exists(@item['is']['meta'], 'enchants')) {
					@i['meta']['enchants'] = array();
					foreach(@enchant: @level in @item['is']['meta']['enchants']) {
						@i['meta']['enchants'][] = array('etype': @enchant, 'elevel': @level);
					}
				}
				if(array_index_exists(@item['is']['meta'], 'repair-cost')) {
					@i['meta']['repair'] = @item['is']['meta']['repair-cost'];
				}
				if(array_index_exists(@item['is']['meta'], 'title')) {
					@i['meta']['title'] = @item['is']['meta']['title'];
				}
				if(array_index_exists(@item['is']['meta'], 'author')) {
					@i['meta']['author'] = @item['is']['meta']['author'];
				}
				if(array_index_exists(@item['is']['meta'], 'pages')) {
					@i['meta']['pages'] = @item['is']['meta']['pages'];
				}
				# TODO: more meta
			}
			@inv[] = @i;
		}
		return(@inv);
	}
	@endpoint = '';
	if($world === 'default') {
		@endpoint = 'groups/default/'.$player.'.yml';
	} else {
		@endpoint = 'worlds/'.$world.'/'.$player.'.yml';
	}
	@original = yml_decode(read('../../../Multiverse-Inventories/'.@endpoint))['SURVIVAL'];
	set_pinv(_parse_inv(json_decode(@original['armorContents']), true));
	set_pinv(_parse_inv(json_decode(@original['inventoryContents'])));
	set_penderchest(_parse_inv(json_decode(@original['enderChestContents'])));
<<<
