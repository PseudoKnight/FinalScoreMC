# Script: Function Documentation
# Author: __import__

# Output colorful information about extensions and functions.
# /doc - List all known extensions, including builtins.
# /doc <extensionname> - List all functions in a given extension.
# /doc <func>[,func] [func] - List specific functions.
*:/doc [$] = >>>
    proc _get_closest(@name, @list) {
        # Search an array for a matching entry, regardless of case, and return it.
        foreach(@ext in @list) {
            if (to_lower(@ext) == to_lower(@name)) {
                return(@ext)
            }
        }
       
    }
   
    proc _desc_func(@func) {
        # Colorfully describe a function.
        try(
            @desc = reflect_docs(@func, 'description')
            @returns = reflect_docs(@func, 'type')
            @args = reflect_docs(@func, 'args')
           
            msg(color(YELLOW) . @func . ':' color(GREEN) . 'Returns' @returns .
            '.' color(BLUE) . 'Expects' @args . '.' color(YELLOW) . @desc)
        ,
            msg(color(RED) . 'Could not show information for' @func)
        )
    }
 
    if (!$) {
        # List known extensions.
        @extensions = array_keys(extension_info())
        if (@extensions) {
            msg(color(BLUE) . 'Installed extensions:')
            foreach (@extension in @extensions) {
                msg(color(RED) . ' - ' . color(GREEN) . @extension)
            }
        } else {
            msg(color(RED) . 'No extensions installed!')
        }
    } else {
        # Show functions in a given extension.
        @args = parse_args($)
        @extensions = extension_info()
       
        # Get extension name regardless of case.
        @extension = _get_closest(@args[0], array_keys(@extensions))
       
        if (@extension) {
            @extension = @extensions[@extension]
            @functions = @extension['functions']
           
            foreach (@function in @functions) {
                _desc_func(@function)
            }
        } else {
            while(@args) {
                @many = split(',', array_remove(@args, 0))
                foreach (@function in @many) {
                    # Get function name regardless of case.
                    @functionname = to_lower(@function)
                    _desc_func(@functionname)
                }
            }
        }
    }
<<<

/*
	Toggles permissions for testing
*/
*:/permtest = >>>
	if(has_permission('group.administrators')) {
		run('/perm player addgroup '.player().' Everyone');
		run('/perm player removegroup '.player().' Administrators');
		export('perm'.player(), 'Administrators');
	} else {
		@perm = import('perm'.player());
		if(!is_null(@perm)) {
			sudo('/perm player addgroup '.player().' Administrators');
			sudo('/perm player removegroup '.player().' Everyone');
		}
	}
<<<

/* 
	Lists the type and amount of events bound
*/
/bindcount = >>>
	@binds = dump_events();
	@list = array();
	foreach(@bind in @binds) {
		@type = reg_match('\\((\\w+)\\).*', @bind)[1];
		if(array_index_exists(@list, @type)) {
			@list[@type] += 1;
		} else {
			@list[@type] = 1;
		}
	}
	
	foreach(@key: @value in @list) {
		msg(@key.': '.@value);
	}
<<<

/*
	Database namespace tools
*/
/namespace $action $namespace [$] = >>>
	if(!pisop(), die('You do not have permission.'))
	@data = get_values($namespace)
	if(array_size(@data) == 0, die('No keys for that namespace.'))
	switch($action) {
		case 'delete':
			foreach(@key: @value in @data) {
				clear_value(@key)
			}
			msg('Deleted '.$namespace)
			
		case 'rename':
			foreach(@key: @value in @data) {
				store_value(replace($namespace, $, @key), @data[@key])
				clear_value(@key)
			}
	}
<<<